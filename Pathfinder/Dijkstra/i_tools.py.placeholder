from typing import Callable, Dict, Hashable, List, Union
from .tools import Node
from Pathfinder.utils import HighComby, LowComby, PathError
from functools import total_ordering
from heapq import heappop

@total_ordering
class INode(Node):
    def __init__(self, id: Hashable, t_func: Callable, connections: Dict["INode", int] = None):
        super().__init__(id, connections)
        self.cost = {0: float("inf")}
        #self.opencost = 
        #self.closedcost = {}
        self.t_func = t_func
    
    def __call__(self, t: int):
        return self.t_func(t)
    
    def __iter__(self):
        for key, value in self.cost.items():
            yield key, value
    
    @property
    def mincost(self):
        return min(self.cost.values())
    
    def pop_mincost(self):
        return self.cost.pop(self.mincost)
    
    def __lt__(self, other):
        if not isinstance(other, type(self)):
            raise NotImplemented
        return self.mincost < other.mincost
    
    def __le__(self, other):
        if not isinstance(other, type(self)):
            raise NotImplemented
        return self.mincost <= other.mincost
    
    def __gt__(self, other):
        if not isinstance(other, type(self)):
            raise NotImplemented
        return self.mincost <= other.mincost

    def __ge__(self, other):
        if not isinstance(other, type(self)):
            raise NotImplemented
        return self.mincost <= other.mincost

def bestpath(startnode: INode, endnode: INode, first_contact: bool = False, queue_type: Union[list, LowComby, HighComby]=list) -> List[INode]:
    """
    Args:
        startnode: starting point
        endnode: ending point
        first_contact: if True, pathfinding will end as soon as the endnode has first been discoverd
        queue_type: type used for queueing nodes; LowComby can be faster but consumes more memory
    
    Returns:
        list of nodes, creating a path
    """
    # get costs
    startnode.cost = 0
    queue: Union[List[INode], LowComby] = queue_type()
    queue.append(startnode)

    while len(queue) != 0:
        currentnode = heappop(queue)
        for node, conncost in currentnode._connections.items():

            for t, cost in currentnode:
                if node(t+1):
                    time_cost = cost + conncost
                    if time_cost < node.cost.get(t+1, float("inf")):
                        node.cost[t+1] = time_cost
                        if node not in queue:
                            queue.append(node)
        
        if endnode.mincost <= currentnode.mincost:
            break
        if first_contact and currentnode is endnode:
            break
    
    # get path
    return construct(startnode, endnode) # TODO: Maybe need time?

def construct(startnode, endnode):
    # get path
    path = [endnode]
    to_check = endnode
    # to_check.mincost #TODO: need to get time from lowest cost
    mincost = to_check.mincost
    t = float("inf")
    for key, value in to_check.cost.items():
        if value == mincost:
            t = key
            break
    else:
        PathError("Coulnd't construct path")
    

    while to_check != startnode:
        for node in to_check._connections.keys():
            if node.cost.get(t-1) + node._connections.get(to_check) == to_check.cost.get(t):
                t -= 1
                path.append(node)
                to_check = node
                break
        else:
            raise PathError("Coulnd't construct path")
        
    path.reverse()
    return path
